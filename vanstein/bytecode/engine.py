"""
The engine class actually runs the bytecode.
"""

try:
    import dis

    dis.Instruction
except AttributeError:
    from vanstein.backports import dis
import inspect

from vanstein.context import _VSContext, VSCtxState, VSWrappedFunction
from vanstein.decorators import native_invoke

from vanstein.bytecode import instructions


class VansteinEngine(object):
    """
    The bytecode virtual machine object runs bytecode that is generated by CPython.
    """

    def __init__(self):
        self.current_instruction = None  # type: dis.Instruction
        self.current_context = None  # type: _VSContext

    @native_invoke
    def __run_natively(self, context: _VSContext, instruction: dis.Instruction):
        """
        Invokes a function natively.
        """
        fn = context.stack.popleft()
        if not callable(fn):
            # TODO: safe_raise
            raise TypeError("'{}' object is not callable".format(fn))
        # Get the number of arguments to pop off of the stack.
        number_of_args = instruction.arg
        args = []
        for x in range(0, number_of_args):
            # Pop each argument off of the stack.
            args.append(context.stack.popleft())

        # Run the function.
        result = fn(*args)

        return result

    @native_invoke
    def run_context(self, context: _VSContext) -> list:
        """
        Runs the current bytecode for a context.

        This will instructions off of the instruction stack, until it reaches a context switch.
        """
        # Welcome to the main bulk of Vanstein.
        # Enjoy your stay!

        # Switch to running state for this context.
        context.state = VSCtxState.RUNNING
        self.current_context = context
        while True:
            if context.state is VSCtxState.FINISHED:
                # Done after a successful RETURN_VALUE.
                # Break the loop, and return the context.
                context.finish()
                return

            if context.state is VSCtxState.ERRORED:
                # TODO: Exception handling
                return

            next_instruction = context.next_instruction()
            assert isinstance(next_instruction, dis.Instruction)
            self.current_instruction = next_instruction

            #print(self.current_instruction, self.current_context)

            # First, we check if we need to context switch.
            # Check if it's CALL_FUNCTION.
            if next_instruction.opname == "CALL_FUNCTION":
                # This is the instruction for CALL_FUNCTION. No specialized one exists in the instructions.py file.

                # We need to context switch, so suspend this current one.
                context.state = VSCtxState.SUSPENDED
                # Get BOS.
                bottom_of_stack = context.stack[0]

                # Here's some context switching.
                # First, check if it's a builtin or is a native invoke.
                if inspect.isbuiltin(bottom_of_stack) or hasattr(bottom_of_stack, "_native_invoke"):
                    # Run it!
                    result = self.__run_natively(context, next_instruction)
                    # Set the result on the context.
                    context.state = VSCtxState.RUNNING
                    # Push the result onto the stack.
                    context.push(result)
                    # Continue the loop to the next instruction.
                    continue

                if isinstance(bottom_of_stack, VSWrappedFunction):
                    # Call the VSWrappedFunction to get a new context.
                    # We'll manually fill these args.
                    new_ctx = bottom_of_stack()

                else:
                    # Wrap the function in a context.
                    new_ctx = _VSContext(bottom_of_stack)

                # Either way, pop it off.

                # Add a callback to the new context, and return it.
                # This is so the loop can schedule execution of the new context soon.
                new_ctx.add_done_callback(context._on_result_cb)
                new_ctx.state = VSCtxState.PENDING
                # Set the previous context, for stack frame chaining.
                new_ctx.prev_ctx = context
                return new_ctx

            # Else, we run the respective instruction.
            try:
                i = getattr(instructions, next_instruction.opname)
            except AttributeError:
                raise NotImplementedError(next_instruction.opname)

            # Call the instruction handler.
            i(context, next_instruction)
